#  Spring Cloud Security Oauth2.0实现分布式系统认证

## 1. 环境介绍

`Spring-Security-Oauth2.0` 是对`Oauth2.0` 的一种实现,并且跟`Spring Security`相辅相成,与`Spring Cloud` 体系的集成也非常便利,接下来,我们需要对它进行学习,最终使用它来实现我们设计的分布式认证授权解决方案

`Oauth2.0` 的服务提供方涵盖两个服务,即授权服务(`Authorization Server`,也叫认证服务)和资源服务(`resource Server`),使用 `Spring Security Oauth2.0`的时候, 你可以选择把他们放在同一个应用程序中去实现,也可以选择建立使用同一个授权服务的多个资源服务.

**授权服务(`Authorization Server`)** 应包含对接入端以及登录用户的合法性进行验证并颁发`token` 等功能,对令牌的请求端点由`Spring MVC`控制器进行实现,下面是一个配置一个认证服务必须实现的`endpoints`: 

-  `AuthorizationEndpoint`:' 服务于认证请求, 默认`URL`:`/oauth/authorize `

- `TokenEndpoint` 服务于访问令牌的请求,默认`URL`: `/oauth/token`

  资源服务(`Resource Server`),应包含对资源的保护功能,对非法请求进行拦截,对请求`token` 进行解析鉴权等,下面的过滤器用于实现`Oauth2.0` 资源服务

- `OAuth2AuthenticationProcessingFilter`:用来对请求给出的身份令牌解析鉴权.



本教程分别创建`UAA`认证中心和`order` 订单资源服务

![image-20200730093122909](7.Spring%20Cloud%20Security%20Oauth2.0%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%A4%E8%AF%81.assets/image-20200730093122909.png)

认证流程如下:

1. 客户端请求`UAA` 授权服务进行认证
2. 认证通过后由`UAA` 颁发令牌
3. 客户端携带令牌`Token`请求资源服务
4. 资源服务校验令牌的合法性,合法则返回资源信息

##  2. 代码演示

### 2.1 创建父工程

创建`maven` 父工程,依赖如下

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.spring.security</groupId>
    <artifactId>spring-security-oauth2-demo</artifactId>
    <version>1.0-SNAPSHOT</version>

    <packaging>pom</packaging>
    <properties>
        <project.build.sourceEncoding>UTF‐8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF‐8</project.reporting.outputEncoding>
        <java.version>1.8</java.version>

    </properties>


    <dependencyManagement>
        <dependencies>


            <dependency>
                <groupId>org.springframework.security.oauth.boot</groupId>
                <artifactId>spring-security-oauth2-autoconfigure</artifactId>
                <version>2.1.3.RELEASE</version>
            </dependency>
            <dependency>
                <groupId>org.springframework.security</groupId>
                <artifactId>spring-security-jwt</artifactId>
                <version>1.0.10.RELEASE</version>
            </dependency>
            <dependency>
                <groupId>mysql</groupId>
                <artifactId>mysql-connector-java</artifactId>
                <version>5.1.46</version>
            </dependency>
            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>fastjson</artifactId>
                <version>1.2.70</version>
            </dependency>
            <dependency>
                <groupId>cn.hutool</groupId>
                <artifactId>hutool-all</artifactId>
                <version>5.3.8</version>
            </dependency>
            <dependency>
                <groupId>org.projectlombok</groupId>
                <artifactId>lombok</artifactId>
                <version>1.18.12</version>
            </dependency>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>Greenwich.RELEASE</version>
                <scope>import</scope>
                <type>pom</type>
            </dependency>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>2.1.3.RELEASE</version>
                <scope>import</scope>
                <type>pom</type>
            </dependency>
        </dependencies>
        
    </dependencyManagement>

    <!--子模块 -->

    <modules>
        <module>uaa</module>
        <module>order</module>

    </modules>


    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <source>1.8</source>
                    <target>1.8</target>
                    <encoding>UTF-8</encoding>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>


    <!--aliyun 私服配置 -->
    <repositories>
        <repository>
            <id>public</id>
            <name>aliyun nexus</name>
            <url>http://maven.aliyun.com/nexus/content/groups/public/</url>
            <releases>
            </releases>
        </repository>
    </repositories>

    <pluginRepositories>
        <pluginRepository>
            <id>public</id>
            <name>aliyun nexus</name>
            <url>http://maven.aliyun.com/nexus/content/groups/public/</url>
            <releases>
            </releases>
            <snapshots>
                <enabled>false</enabled>
            </snapshots>
        </pluginRepository>
    </pluginRepositories>
</project>

```

里面主要定义了`Spring Boot`的版本和`Spring Cloud`的版本



### 2.2 创建`UAA` 授权服务工程

1. `pom` 依赖

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
       <modelVersion>4.0.0</modelVersion>
   
   
       <parent>
           <groupId>com.spring.security</groupId>
           <artifactId>spring-security-oauth2-demo</artifactId>
           <version>1.0-SNAPSHOT</version>
       </parent>
       <groupId>com.spring.security.uaa</groupId>
       <artifactId>uaa</artifactId>
       <version>0.0.1-SNAPSHOT</version>
       <name>uaa</name>
       <description>授权认证服务</description>
   
       <properties>
           <java.version>1.8</java.version>
           <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
           <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
   
       </properties>
   
       <dependencies>
   
           <!--wen组件 -->
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-web</artifactId>
           </dependency>
   
           <!--端点监控 -->
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-actuator</artifactId>
           </dependency>
   
           <!--服务调用 -->
           <dependency>
               <groupId>org.springframework.cloud</groupId>
               <artifactId>spring-cloud-starter-openfeign</artifactId>
           </dependency>
           <!--负载均衡 -->
           <dependency>
               <groupId>org.springframework.cloud</groupId>
               <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
           </dependency>
   
   
           <!--  熔断-->
           <dependency>
               <groupId>org.springframework.cloud</groupId>
               <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
           </dependency>
   
           <!--注册中心 -->
           <dependency>
               <groupId>org.springframework.cloud</groupId>
               <artifactId>spring-cloud-netflix-eureka-client</artifactId>
           </dependency>
   
   
           <!--认证授权相关 -->
           <dependency>
               <groupId>org.springframework.cloud</groupId>
               <artifactId>spring-cloud-starter-oauth2</artifactId>
           </dependency>
           <dependency>
               <groupId>org.springframework.cloud</groupId>
               <artifactId>spring-cloud-starter-security</artifactId>
           </dependency>
   
           <dependency>
               <groupId>org.springframework.security</groupId>
               <artifactId>spring-security-jwt</artifactId>
           </dependency>
   
   
           <!-- 认证授权end-->
   
           <dependency>
               <groupId>mysql</groupId>
               <artifactId>mysql-connector-java</artifactId>
           </dependency>
   
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-jdbc</artifactId>
           </dependency>
   
   
           <dependency>
               <groupId>org.projectlombok</groupId>
               <artifactId>lombok</artifactId>
           </dependency>
   
           <dependency>
               <groupId>com.alibaba</groupId>
               <artifactId>fastjson</artifactId>
           </dependency>
   
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-test</artifactId>
               <scope>test</scope>
               <exclusions>
                   <exclusion>
                       <groupId>org.junit.vintage</groupId>
                       <artifactId>junit-vintage-engine</artifactId>
                   </exclusion>
               </exclusions>
           </dependency>
       </dependencies>
   
   </project>
   
   ```

2. 编写启动类`UaaApplication`

   ```java
   
   @EnableHystrix
   @EnableFeignClients
   @EnableDiscoveryClient
   @SpringBootApplication
   public class UaaApplication {
   
       public static void main(String[] args) {
           SpringApplication.run(UaaApplication.class, args);
       }
   
   }
   
   ```

3. 编写配置文件`application.yml`

   ```yaml
   spring:
     application:
       name: uaa
     main:
       allow-bean-definition-overriding: true
     http:
       encoding:
         charset: UTF-8
         enabled: true
         force: true
     datasource:
       url: jdbc:mysql://localhost:3306/spring-security-oauth2-demo
       username: root
       password: rootroot
       driver-class-name: com.mysql.jdbc.Driver
     mvc:
       throw-exception-if-no-handler-found: true
     resources:
       add-mappings: false
   
   
   server:
     port: 8000
     tomcat:
       remote-ip-header: x‐forwarded‐for
       protocol-header: x‐forwarded‐proto
     use-forward-headers: true
     servlet:
       context-path: /uaa
   
   
   
   
   
   logging:
     level:
       root: info
   
   feign:
     hystrix:
       enabled: true
     compression:
       request:
         enabled: true
         mime-types:
           - text/html
           - appliication/xml
           - application/json
         min-request-size: 2048
       response:
         enabled: true
   
   ```

4. 结构预览

   ![image-20200730134311459](7.Spring%20Cloud%20Security%20Oauth2.0%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%A4%E8%AF%81.assets/image-20200730134311459.png)





### 2.3  编写`Order` 资源服务项目

本工程为`Order` 订单服务工程,访问本工程的资源需要认证通过

本工程的目的主要是为了测试认证授权功能,所以不会涉及订单的相关业务逻辑. 

1. `pom.xml`

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
       <modelVersion>4.0.0</modelVersion>
   
   
       <parent>
           <groupId>com.spring.security</groupId>
           <artifactId>spring-security-oauth2-demo</artifactId>
           <version>1.0-SNAPSHOT</version>
       </parent>
       <groupId>com.spring.security.order</groupId>
       <artifactId>order</artifactId>
       <version>0.0.1-SNAPSHOT</version>
       <name>order</name>
       <description>订单模块</description>
   
   
       <dependencies>
   
           <!-- 认证授权相关-->
   
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-security</artifactId>
           </dependency>
           <dependency>
               <groupId>org.springframework.cloud</groupId>
               <artifactId>spring-cloud-starter-oauth2</artifactId>
           </dependency>
   
   
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-jdbc</artifactId>
           </dependency>
           <dependency>
               <groupId>mysql</groupId>
               <artifactId>mysql-connector-java</artifactId>
           </dependency>
           <dependency>
               <groupId>com.alibaba</groupId>
               <artifactId>fastjson</artifactId>
           </dependency>
           <dependency>
               <groupId>org.projectlombok</groupId>
               <artifactId>lombok</artifactId>
           </dependency>
           <dependency>
               <groupId>org.springframework.cloud</groupId>
               <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
           </dependency>
           <dependency>
               <groupId>org.springframework.cloud</groupId>
               <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
           </dependency>
           <dependency>
               <groupId>org.springframework.cloud</groupId>
               <artifactId>spring-cloud-starter-openfeign</artifactId>
           </dependency>
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-web</artifactId>
           </dependency>
   
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-actuator</artifactId>
           </dependency>
           <dependency>
               <groupId>org.springframework.cloud</groupId>
               <artifactId>spring-cloud-netflix-eureka-client</artifactId>
           </dependency>
   
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter</artifactId>
           </dependency>
   
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-test</artifactId>
               <scope>test</scope>
               <exclusions>
                   <exclusion>
                       <groupId>org.junit.vintage</groupId>
                       <artifactId>junit-vintage-engine</artifactId>
                   </exclusion>
               </exclusions>
           </dependency>
       </dependencies>
   
   
       <build>
           <plugins>
               <plugin>
                   <groupId>org.apache.maven.plugins</groupId>
                   <artifactId>maven-compiler-plugin</artifactId>
                   <configuration>
                       <source>1.8</source>
                       <target>1.8</target>
                       <encoding>UTF-8</encoding>
                   </configuration>
               </plugin>
               <plugin>
                   <groupId>org.springframework.boot</groupId>
                   <artifactId>spring-boot-maven-plugin</artifactId>
               </plugin>
           </plugins>
       </build>
   
   </project>
   
   ```

2. `Order`的启动类

   ```java
   @EnableHystrix
   @EnableFeignClients
   @EnableDiscoveryClient
   @SpringBootApplication
   public class OrderApplication {
   
       public static void main(String[] args) {
           SpringApplication.run(OrderApplication.class, args);
       }
   
   }
   ```

3. 配置文件`application.yml`

   ```yaml
   server:
     port: 8081
     tomcat:
       remote-ip-header: x‐forwarded‐for
       protocol-header: x‐forwarded‐proto
     use-forward-headers: true
     servlet:
       context-path: /order
   
   
   spring:
     application:
       name: order
     main:
       allow-bean-definition-overriding: true
     http:
       encoding:
         charset: UTF-8
         enabled: true
         force: true
     datasource:
       url: jdbc:mysql://localhost:3306/spring-security-oauth2-demo
       username: root
       password: rootroot
       driver-class-name: com.mysql.jdbc.Driver
     mvc:
       throw-exception-if-no-handler-found: true
     resources:
       add-mappings: false
   
   
   feign:
     hystrix:
       enabled: true
     compression:
       request:
         enabled: true
         mime-types:
           - text/html
           - appliication/xml
           - application/json
         min-request-size: 2048
       response:
         enabled: true
   
   
   ```



项目的基本框架现在已经搭建了

### 2.4 授权服务器设置(`uaa`)

####   2.4.1  ` EnableAuthorizationServer`

可以用` EnableAuthorizationServer`注解并继承`AuthorizationServerConfigurerAdapter` 来配置`Oauth2.0` 授权服务器.

在`config` 包下创建 `AuthorizationServer`

`AuthorizationServerConfigurerAdapter`  要求配置以下几个类,这几个类是由`Spring` 创建的独立的配置对象,他们会被`Spring`传入`AuthorizationServerConfigurerAdapter ` 中进行配置. 

```java
public class AuthorizationServerConfigurerAdapter implements AuthorizationServerConfigurer {
    public AuthorizationServerConfigurerAdapter() {
    }

    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
    }

    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
    }

    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
    }
}

```

- `ClientDetailsServiceConfigurer`:用来配置客户端详情服务(`ClientDetailsService`),客户端详情信息在这里进行初始化,可以通过客户端详细写死在这里或者通过数据库来存储调取详情信息. 
- `AuthorizationServerEndpointsConfigurer`: 用来配置令牌`token` 的访问端点和令牌服务(`token service`)
- `AuthorizationServerSecurityConfigurer`: 用来配置令牌端点的安全约束



#### 2.4.2 配置客户端相信信息

`ClientDetailsServiceConfigurer` 可以使用内存或者JDBC来实现客户端详细信息服务(`ClientDetailsService`)

`ClientDetailsService` 负责查找`ClientDetails`, 而`ClientDetails` 有几个重要的属性如下列表: 

- `clientId`(必须): 用来标识客户的`id`
- `secret`: (需要值得信任的客户端)客户端安全码,如果有的话,
- `scope` :用来限制客户端的访问范围, 如果为空(默认的话), 那么客户端将拥有全部的访问范围. 
- `authorizedGrantTypes`:此客户端可以使用的授权类型,默认为空
- `authorities` 此客户端可以使用的权限(基于`Spring Security  authorities`)

客户端详情(`client details`) 能够在应用程序运行的时候进行更新,可以通过访问底层的存储服务(例如将客户端详情存储在一个关系型数据库的表中,就可以使用`jdbcClientDetailsService`) 或者通过自己实现`ClientRegistrationService` 接口(同时实现`ClientDetailsServcice` 接口) 来进行管理. 

```java
 @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {

        clients.inMemory()  // 使用内存进行存储
                .withClient("c1") // client_id
                .secret(new BCryptPasswordEncoder().encode("secret")) //秘钥
                .resourceIds("res1") // 资源id
                .authorizedGrantTypes("authorization_code",
                        "password", "client_credentials",
                        "implicit", "refresh_token") // 该client允许的授权类型
                .scopes("all") // 允许授权的范围
                .autoApprove(true)
                // 验证回调地址
                .redirectUris("http://baidu.com");
    }
```



#### 2.4.3 管理令牌

`AuthorizationServerTokenService`接口定义了一些操作使得你可以对令牌进行一些必要的管理,令牌可以被用来加载身份信息,里面包含了这个令牌的相关权限. 

自己可以创建`AuthorizationServerTokenService` 这个接口的实现,则需要继承`DefaultTokenServices` 这个类, 里面包含了一些有用的实现,可以使用它来修改令牌的格式和令牌的存储. 默认的,当它尝试创建一个令牌的时候,是使用随机值来进行填充的,除了持久化令牌是委托一个`tokenStore` 接口来实现以外,这个类几乎帮你做了所有的事情,并且`TokenStore` 这个接口有一个默认的实现`InMemoryTokenStore`, 基于内存的令牌保存实现. 除了使用这个类之外, 你还可以使用一些其他的预定义的实现,下面有几个版本,他们都实现了`TokenStore` 接口. 

- `InMemoryTokenStore`:这个版本都实现是被默认采用的,它可以完美的工作在单机服务器上(即访问并发量不大的情况下, 并且它在失败的时候不会进行备份), 大多数的项目都可以使用这个版本的实现来进行尝试, 一般可以在开发的时候使用它进行管理, 因为不会被保存在磁盘中, 所以更易于调试. 
- `JdbcTokenStore`: 这是一个基于`JDBC`的实现版本, 令牌会被保存在关系型数据库中,使用这个版本的实现的时候,你可以在不同的服务器之间共享信息,使用这个版本的时候注意把`spring-jdbc`这个依赖加入到项目中. 
- `JwtTokenStore`: 这个版本的全称是`JSON Web Token（JWT）`,它可以把令牌相关的数据进行编码(因此相对于后端服务来说, 它不需要进行存储,这是一个重大的优势),但是它有一个缺点,就是撤销一个已经授权的令牌将会非常困难,所以它通常用来处理一个生命周期很短的令牌以及撤销刷新令牌(`refresh token`), 另一个缺点就是这个令牌会占用的空间会比较大 , 如果你加入了比较多的用户凭证信息,`JwtTokenStore` 不会保存任何数据,它是它在转换令牌以及授权信息等方法跟 `DefaultTokenServices ` 所扮演的角色是一样的. 

1. 定义`TokenConfig`

    在`config`包下定义`TokenConfig`, 我们暂时使用`InMemoryTokenStore`, 生成一个普通的令牌. 

   ```java
   @Configuration
   public class TokenConfig {
   
       @Bean
       public TokenStore tokenStore() {
           // 使用内存存储令牌
           return new InMemoryTokenStore();
       }
   
   }
   ```

2. 定义 `AuthorizationServerTokenServices`

   在`AuthorizationServer` 中定义`AuthorizationServerTokenServices`

   ```java
   
       @Autowired
       private TokenStore tokenStore;
   
       @Autowired
       private ClientDetailsService clientDetailsService;
   
   
       @Bean
       public AuthorizationServerTokenServices authorizationServerTokenServices() {
           DefaultTokenServices services = new DefaultTokenServices();
           services.setClientDetailsService(clientDetailsService);
           services.setSupportRefreshToken(true);
           services.setTokenStore(tokenStore);
           services.setAccessTokenValiditySeconds(7200);//令牌默认的有效时间为2小时
           services.setRefreshTokenValiditySeconds(259200);//刷新令牌默认有效期为3天
   
           return services;
       }
       
   ```

   

#### 2.4.4 令牌访问端点配置

`AuthorizationServerEndpointsConfigurer` 这个对象的实例可以完成令牌服务以及令牌`endpoint` 的配置

##### 配置授权类型(`Grant Types`)

`AuthorizationServerEndpointsConfigurer`  通过设定以下属性来决定支持的授权类型(`Grant Types`)

- `authenticationManager`: 认证管理器 ,当你选择了资源所有者的密码(`password`)授权类型的时候,请设置这个属性注入一个`AuthenticationManager` 对象
- `userDetailsService`:如果你设置了这个属性,那说明你有一个自己定义的`UserDetailsService` 接口的实现,或者你可以把这个东西设置到全局域上面去(例如`GlobalAuthenticationManagerConfigurer` 这个配置对象), 当你设置了这个后, 那么`refresh_token`即刷新令牌授权类型模式的流程中就会包含一个检查,用来确保这个账号是否仍然有效,假如说你禁用了这个账号了的话. 
-  `authorizationCodeServices`: 这个属性是用来设置授权码服务(即` AuthorizationCodeServices` 的实例对象),主要用于`authorization_code` 授权码类型模式. 
- `implicitGrantService`:  这个属性用于设置隐形授权模式,用来管理隐式授权模式的状态. 
- `tokenGranter`: 当你设置了这个东西(即`tokenGranter`接口实现), 那么授权就会交给你完全掌握,并且会忽略掉上面的几个属性, 这个属性一般是用作扩展用途的,即标准的四种授权模式已经满足不了你的需求的时候, 才会用到这个. 





##### 配置授权端点的`URL`(Endpoint URLs)

`AuthorizationServerEndpointsConfigurer`  这个配置对象有一个叫做`pathMapping()` 方法来配置端点`URL`连接, 它有两个参数: 

- 第一个参数: `String` 类型的,这个端点`URL` 的默认链接. 
- 第二个参数: `String` 类型的, 你要进行替代的`URL` 链接. 

以上的参数都将以`/` 字符为开始的字符串,框架默认的`URL`链接如下列表,可以作为这个`pathMapping()` 方法的第一个参数

- `/oauth/authorize`: 授权端点
- `/oauth/token`: 令牌端点
- `/oauth/confirm_access`:用户确认授权提交端点
- `/oauth/error`: 授权服务错误信息端点
- `/oauth/check_token`: 用于资源服务访问的令牌解析端点
- `/oauth/token_key`:提供公有密钥的端点,如果你使用`JWT`令牌的话.



需要注意的是授权端点这个`URL`应该被`Spring Security`保护起来只供授权用户访问. 

在`AuthorizationServer` 中配置令牌访问端点

```java


    @Autowired
    private AuthenticationManager authenticationManager;

    @Autowired
    private AuthorizationCodeServices authorizationCodeServices;

    /**
     * <p>令牌访问端点</p>
     *
     * @param endpoints
     * @author luyanan
     * @since 2020/7/30
     */
    @Override
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
        endpoints.authenticationManager(authenticationManager)
                .authorizationCodeServices(authorizationCodeServices)
                .tokenServices(authorizationServerTokenServices())
                .allowedTokenEndpointRequestMethods(HttpMethod.POST);


    }


    @Bean
    public AuthorizationCodeServices authorizationCodeServices() {

        // 设置授权码模式的授权码如何存储, 暂时采用内存存储的方式
        return new InMemoryAuthorizationCodeServices();
    }

 



```



#### 2.4.5  令牌端点的安全约束

`AuthorizationServerSecurityConfigurer` 用来配置令牌端点(`Token Endpoint`) 的安全约束,在`AuthorizationServer` 中配置如下

```java
   //令牌端点安全约束
    @Override
    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
        security.tokenKeyAccess("permitAll()")  //(1)
                .checkTokenAccess("permitAll()") //(2)
                .allowFormAuthenticationForClients();//(3)
    }
```

1. `tokenkey`  这个`endpoint` 当使用`jwtToken` 且使用非对称加密的时候, 资源服务用于获取公钥而开放,这里指这个`endpoint` 完全开放. 
2. `checkToken` 在个`endpoint` 完全公开
3. 允许表单认证



##### 授权服务器总结: 授权服务配置分为三大块,可以关联记忆

既然要完成认证,它首先要知道客户端信息从哪里读取,因此要进行客户端详情配置. 

既然要颁发`token`, 那必须要定义`token` 的相关`endpoint` , 以及`token` 如何存取,以及客户端支持哪些类型的`token`. 

既然暴露了一些`endpoint`, 那对这些`endpoint` 可以定义一些安全上的约束等. 



#### 2.4.5 `web` 安全配置

在`config`包路径下添加`WebSecurityConfig`文件

```java
@Configuration
@EnableGlobalMethodSecurity(securedEnabled = true, prePostEnabled = true)
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {


    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }


    // 安全拦截机制
    @Override
    protected void configure(HttpSecurity http) throws Exception {

        http.csrf().disable()
                .authorizeRequests()
                .antMatchers("/r/r1").hasAnyAuthority("p1")
                .antMatchers("/r/r2").hasAnyAuthority("p2")
                .antMatchers("/login").permitAll()
                .anyRequest().authenticated()
                .and().formLogin();
    }
}

```



### 2.5 授权码模式

#### 2.5.1 授权码模式介绍

下面是授权码模式的交互流程

![image-20200730170503738](7.Spring%20Cloud%20Security%20Oauth2.0%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%A4%E8%AF%81.assets/image-20200730170503738.png)



1. 资源拥有者打开客户端,客户端要求资源拥有者给予授权,它将浏览器被重定向到授权服务器,重定向时会附加客户端的身份信息,如:

   ```text
   /uaa/oauth/authorize?client_id=c1&response_type=code&scope=all&redirect_uri=http://www.baidu.com
   
   ```

   参数列表如下: 

   - `client_id`:  客户端准入标识
   - `response_type`：授权码模式固定为`code`
   - `scope`: 客户端权限
   - `redirect_uri`:跳转`url`, 当授权码申请成功后将跳转到此地址,并在后面带上`code`参数(授权码)

   